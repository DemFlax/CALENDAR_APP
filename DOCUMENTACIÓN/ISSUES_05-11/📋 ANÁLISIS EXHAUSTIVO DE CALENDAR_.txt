üìã AN√ÅLISIS EXHAUSTIVO DE CALENDAR_APP - INFORME DE ISSUES

He completado un an√°lisis profundo del repositorio considerando el contexto general de la aplicaci√≥n. A continuaci√≥n te presento los issues cr√≠ticos, bugs e incoherencias encontrados, organizados por categor√≠a y prioridad:
üö® CR√çTICOS - SEGURIDAD (Acci√≥n Inmediata Requerida)
C1. Credenciales Expuestas en C√≥digo Frontend

Ubicaci√≥n: /public/js/firebase-config.js:5-16
Problema:

const firebaseConfig = {
  apiKey: "AIzaSyA2K1hWVovDGcVart7XFEbTqJuQRErPRTI", // ‚ùå EXPUESTO
  // ... otras credenciales expuestas
};

export const appsScriptConfig = {
  url: 'https://script.google.com/macros/s/...',
  apiKey: 'sfs-calendar-2024-secure-key' // ‚ùå API KEY HARDCODED
};

Riesgo: Las Firebase API keys son p√∫blicas por dise√±o, PERO el Apps Script API Key NO deber√≠a estar hardcoded. Cualquiera con acceso al c√≥digo puede hacer peticiones directas al Apps Script.
Impacto: Alto - Acceso no autorizado a Google Calendar API
Soluci√≥n: Mover Apps Script API Key a Firestore rules o validar requests en Apps Script usando Firebase Auth tokens.
C2. Service Account Key con Ruta Hardcoded Windows

Ubicaci√≥n: /functions/config/admin-config.js:4
Problema:

const KEYS_PATH = 'C:\\SHERPAS_CALENDAR\\Kyes\\serviceAccountKey.json'; // ‚ùå

Riesgo:

    Path de Windows no funciona en producci√≥n (Cloud Functions usa Linux)
    Ruta absoluta expone estructura de archivos de desarrollo
    El archivo serviceAccountKey.json contiene credenciales de administrador total de Firebase
    TYPO en "Kyes" (deber√≠a ser "Keys")

Impacto: Cr√≠tico - Cloud Functions NO funcionar√°n en producci√≥n
Soluci√≥n:

    Usar variables de entorno con Secret Manager para las credenciales
    En local, usar path relativo o GOOGLE_APPLICATION_CREDENTIALS
    Verificar que serviceAccountKey.json est√© en .gitignore

C3. Falta Validaci√≥n de Propiedad en vendor-costs

Ubicaci√≥n: /functions/src/vendor-costs.js:815-930
Problema: La funci√≥n registerVendorCost permite a un gu√≠a registrar costos para cualquier shift solo validando que:

if (shift.estado !== 'ASIGNADO') {
  throw new HttpsError('failed-precondition', 'Shift not assigned');
}

Pero NO valida que el shift est√© asignado al gu√≠a que hace el request.

Riesgo: Un gu√≠a puede registrar vendor costs de shifts de otros gu√≠as.
Impacto: Alto - Manipulaci√≥n de salarios
Soluci√≥n: Agregar validaci√≥n:

if (shift.guideId !== guideId) {
  throw new HttpsError('permission-denied', 'Shift no pertenece a este gu√≠a');
}

C4. Firestore Rules - Escalation Privilege en guide_invoices

Ubicaci√≥n: /firestore.rules:78-81
Problema:

allow update: if isGuide() && 
  resource.data.guideId == request.auth.token.guideId &&
  resource.data.status == "PENDING_APPROVAL" &&
  request.resource.data.status == "APPROVED";

Pero NO valida que el gu√≠a no modifique otros campos (totalSalary, tours, etc.)

Riesgo: Un gu√≠a malicioso podr√≠a:

    Interceptar la petici√≥n de guideApproveReport
    Modificar totalSalary mientras cambia status a APPROVED

Impacto: Alto - Manipulaci√≥n de salarios
Soluci√≥n: Cambiar a:

allow update: if isGuide() && 
  resource.data.guideId == request.auth.token.guideId &&
  resource.data.status == "PENDING_APPROVAL" &&
  request.resource.data.status in ["APPROVED", "REJECTED"] &&
  request.resource.data.diff(resource.data).affectedKeys()
    .hasOnly(['status', 'guideApprovedReportAt', 'rejectionComments', 'rejectedAt', 'updatedAt']);

‚ö†Ô∏è ALTOS - RACE CONDITIONS Y CONCURRENCIA
A1. Generaci√≥n Duplicada de Shifts en onCreateGuide/onUpdateGuide

Ubicaci√≥n: /functions/index.js:206-227 y 346-376
Problema: Ambas funciones generan 3 meses de shifts SIN verificar si ya existen:

for (let monthOffset = 0; monthOffset < 3; monthOffset++) {
  const created = await generateMonthShifts(guideId, year, month); // ‚ùå No verifica existencia
}

Escenario de fallo:

    Manager crea gu√≠a ‚Üí onCreateGuide genera shifts
    Si falla el email, manager reintenta crear gu√≠a con mismo email
    Auth lanza error auth/email-already-exists pero shifts ya fueron creados
    Manager desactiva y reactiva gu√≠a ‚Üí onUpdateGuide genera shifts duplicados

Impacto: Medio - Shifts duplicados, inconsistencia en calendario
Soluci√≥n: En generateMonthShifts, verificar existencia antes de crear:

const existingShift = await docRef.get();
if (existingShift.exists) {
  continue; // Skip si ya existe
}
batch.set(docRef, {...});

A2. Race Condition en Bookeo Email State

Ubicaci√≥n: /functions/src/bookeo-rate-limiting.js:477-490 y 693-708
Problema: M√∫ltiples triggers de shifts pueden ejecutarse simult√°neamente. Aunque hay transacci√≥n at√≥mica para email state, no hay debounce global por fecha.

Escenario:

    Gu√≠a bloquea T1 ‚Üí Trigger 1 ejecuta
    Inmediatamente bloquea T2 ‚Üí Trigger 2 ejecuta
    Ambos calculan guidesDisponiblesTarde === 0 simult√°neamente
    El segundo trigger puede pasar la transacci√≥n si el primero no ha actualizado el estado a√∫n

Impacto: Medio - M√∫ltiples emails al manager para la misma fecha
Soluci√≥n: Agregar debounce de 5 segundos usando Cloud Tasks para agrupar cambios de la misma fecha.
A3. generateMonthlyShifts No Usa Locks Distribuidos

Ubicaci√≥n: /functions/index.js:706-905
Problema: El cron mensual procesa todos los gu√≠as en paralelo:

for (const guideDoc of guidesSnapshot.docs) {
  const created = await generateMonthShifts(guideId, targetYear, targetMonth);
}

Si se ejecuta manualmente mientras el cron est√° corriendo, pueden crearse shifts duplicados.

Impacto: Bajo - Solo si hay ejecuci√≥n manual concurrente
Soluci√≥n: Usar Firestore transaction lock:

const lockRef = db.collection('system_locks').doc(`generate_shifts_${monthStr}`);
await db.runTransaction(async (t) => {
  const lock = await t.get(lockRef);
  if (lock.exists && lock.data().lockedAt > Date.now() - 600000) {
    throw new Error('Ya hay un proceso en ejecuci√≥n');
  }
  t.set(lockRef, { lockedAt: Date.now() });
});

üêõ MEDIOS - BUGS DE L√ìGICA
M1. Inconsistencia en vendor-costs: pagoBruto vs salarioCalculado

Ubicaci√≥n: /functions/src/vendor-costs.js:51 y 878-896
Problema:

    calculateSalary retorna range.pagoBruto (l√≠nea 51)
    Pero se guarda como salarioCalculado en la colecci√≥n (l√≠nea 896)
    En generateGuideInvoices, se suma cost.salarioCalculado (l√≠nea 207)

SI la tabla de config usa el campo correcto (pagoBruto), funciona. Pero hay inconsistencia de nombres.

Impacto: Medio - Confusi√≥n, posible error si se cambia la estructura
Soluci√≥n: Unificar nomenclatura a salarioCalculado en todos los lugares.
M2. Validaci√≥n de Fecha en vendor_costs Incorrecta

Ubicaci√≥n: /firestore.rules:66-69 y /functions/src/vendor-costs.js:841-847
Problema:

    Rules permite update si request.time < resource.data.createdAt + duration.value(1, 'd')
    Pero Cloud Function valida diffDays > 7 (l√≠nea 846)

Incoherencia: ¬øGu√≠a puede editar 24h o 7 d√≠as?

Impacto: Bajo - Confusi√≥n en reglas de negocio
Soluci√≥n: Alinear ambas validaciones (recomendado: 24h en ambas).
M3. BookeoId Faltante Bloquea Desbloqueos Autom√°ticos

Ubicaci√≥n: /functions/src/bookeo-rate-limiting.js:102-179
Problema: Si Zapier no retorna bookeoId, se guarda null:

if (bookeoId) {
  await db.collection('bookeo_blocks').doc(shiftId).set({ bookeoId, ... });
} else {
  await db.collection('bookeo_blocks').doc(shiftId).set({
    bookeoId: null, // ‚ùå
    warning: 'bookeoId no retornado - DESBLOQUEO IMPOSIBLE'
  });
}

Luego, al intentar desbloquear (l√≠nea 540-610), salta el webhook si falta bookeoId.

Impacto: Medio - Turnos bloqueados indefinidamente requieren intervenci√≥n manual
Soluci√≥n: Ya hay emails cr√≠ticos, pero deber√≠a haber un endpoint manual para que manager pueda registrar bookeoId despu√©s.
M4. generateGuideInvoices Usa Field Incorrecto

Ubicaci√≥n: /functions/src/vendor-costs.js:205-214
Problema:

costsSnap.forEach(doc => {
  const cost = doc.data();
  totalSalary += cost.salarioCalculado; // ‚ùå ¬øEste campo existe?
  tours.push({
    ...
    salario: cost.salarioCalculado
  });
});

Pero en registerVendorCost (l√≠nea 896) se guarda como:

salarioCalculado,  // ‚úÖ Correcto

Verificar: ¬øLa estructura de vendor_costs es coherente? Parece que s√≠, pero falta documentaci√≥n.

Impacto: Bajo - Si funciona, no hay problema. Pero falta validaci√≥n.
Soluci√≥n: Agregar validaci√≥n en la query para asegurar que el campo existe.
üìù BAJOS - VALIDACIONES Y MEJORAS
B1. No Hay Validaci√≥n de Email Format

Ubicaci√≥n: Frontend: /public/js/manager-guides.js y Backend: /functions/index.js:133-136
Problema: Se acepta cualquier string como email sin validar formato.

Impacto: Bajo - Firebase Auth valida, pero mala UX
Soluci√≥n: Agregar regex en frontend:

if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
  throw new Error('Email inv√°lido');
}

B2. No Hay Validaci√≥n de DNI Espa√±ol

Ubicaci√≥n: Manager guide form
Problema: El campo dni acepta cualquier valor, pero deber√≠a validar formato espa√±ol (8 d√≠gitos + letra).

Impacto: Bajo - Datos inconsistentes
Soluci√≥n: Validar con:

function validateDNI(dni) {
  const dniRegex = /^[0-9]{8}[A-Z]$/;
  if (!dniRegex.test(dni)) return false;
  
  const letters = 'TRWAGMYFPDXBNJZSQVHLCKE';
  const number = parseInt(dni.substr(0, 8), 10);
  const letter = dni.charAt(8);
  return letters[number % 23] === letter;
}

B3. onSnapshot Listeners No Se Limpian en Errores

Ubicaci√≥n: /public/js/manager-dashboard.js:135-149 y /public/js/guide-dashboard.js
Problema: Si un listener falla, no se limpia:

const unsub = onSnapshot(shiftsQuery, (snapshot) => {
  // Si snapshot tiene error, unsub nunca se agrega a shiftsUnsubscribes
  shiftsUnsubscribes.push(unsub); // ‚ùå No se ejecuta si hay error arriba
});

Impacto: Bajo - Memory leaks en caso de errores
Soluci√≥n:

const unsub = onSnapshot(shiftsQuery, 
  (snapshot) => { /* success */ },
  (error) => { 
    console.error(error);
    // Listener se auto-limpia en error
  }
);
shiftsUnsubscribes.push(unsub); // Agregar inmediatamente

B4. ZAPIER_WEBHOOK_URL Puede Ser Undefined

Ubicaci√≥n: /functions/src/bookeo-rate-limiting.js:1032-1036
Problema:

if (!ZAPIER_WEBHOOK_URL) {
  logger.warn('ZAPIER_WEBHOOK_URL no configurado', { shiftId });
  return; // ‚ùå Silencioso, no lanza error
}

Impacto: Bajo - Sistema no bloquea/desbloquea en Bookeo, pero no hay alerta cr√≠tica
Soluci√≥n: En producci√≥n, esto deber√≠a fallar ruidosamente y enviar email al manager.
B5. Apps Script Timeout Hardcoded a 10s

Ubicaci√≥n: /public/js/calendar-api.js:59
Problema:

const timeout = options.timeout || 10000; // 10s

Pero getTourGuestDetails puede tardar m√°s si el calendar tiene muchos eventos.

Impacto: Bajo - UX degradada en calendars grandes
Soluci√≥n: Aumentar a 30s o hacer configurable.
üîß INCOHERENCIAS DE CONFIGURACI√ìN
CF1. Node Version Mismatch

Ubicaci√≥n: /package.json:24 vs /functions/package.json
Verificar: ¬øAmbos package.json especifican Node 20? Root dice "node": "20" pero falta verificar functions.

Soluci√≥n: Asegurar coherencia en versi√≥n de Node.
CF2. Firestore Indexes Posiblemente Incompletos

Ubicaci√≥n: /firestore.indexes.json
Problema: No hay √≠ndice compuesto para:

    vendor_costs: guideId + fecha + createdAt (usado en generateGuideInvoices)
    shifts: guideId + estado + fecha (usado en m√∫ltiples queries)

Impacto: Bajo - Queries lentas si hay muchos documentos
Soluci√≥n: Revisar logs de Firestore y agregar √≠ndices faltantes.
CF3. Frontend Usa CDN de Firebase 10.8.0

Ubicaci√≥n: Todos los archivos JS del frontend
Problema: Versi√≥n hardcoded puede tener vulnerabilidades.

Impacto: Bajo - Hasta que haya CVE conocido
Soluci√≥n: Actualizar a √∫ltima versi√≥n de Firebase JS SDK (10.14.x).
üéØ RESUMEN PRIORIZADO

| ID | Categor√≠a | Prioridad | Impacto | Esfuerzo | |----|-----------|-----------|---------|----------| | C2 | Seguridad | üî¥ Cr√≠tico | Alto | Bajo | | C3 | Seguridad | üî¥ Cr√≠tico | Alto | Bajo | | C4 | Seguridad | üî¥ Cr√≠tico | Alto | Medio | | C1 | Seguridad | üü† Alto | Alto | Medio | | A1 | Race Condition | üü† Alto | Medio | Bajo | | A2 | Race Condition | üü† Alto | Medio | Alto | | M3 | Bug L√≥gica | üü° Medio | Medio | Medio | | M1 | Inconsistencia | üü° Medio | Bajo | Bajo | | B4 | Validaci√≥n | üü¢ Bajo | Bajo | Bajo |
üìå RECOMENDACIONES GENERALES

    Agregar tests unitarios para Cloud Functions cr√≠ticas (vendor-costs, bookeo-rate-limiting)
    Implementar logging estructurado con correlation IDs para tracing
    Agregar monitoring de Cloud Functions (latencia, error rate)
    Documentar reglas de negocio para evitar incoherencias entre backend/frontend/rules
    Implementar rate limiting en Apps Script para prevenir abuso del API Key

¬øQuieres que profundice en alg√∫n issue espec√≠fico o te ayude a generar los fixes para los cr√≠ticos?